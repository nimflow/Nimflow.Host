{"version":3,"sources":["env-vars.ts","utils/uischema-scope-validator.ts","libs/yup.ts","utils/graph-algorithms.ts","utils/get-base-url.ts","libs/json-schema-ref-parser.ts","libs/i18next.ts","libs/ajv.ts","../node_modules/ajv-i18n/localize lazy /^/.*/index$/ groupOptions: {} namespace object","serviceWorker.ts","index.tsx","models/importers.ts"],"names":["publicUrl","process","_businessDirectoryServerUrl","env","Error","businessDirectoryServerUrl","auth0Domain","auth0ClientId","auth0Audience","enableContextTypeDiagram","enableContextTypeRecalculate","persistedConfigurationStorageKey","isScopable","value","hasNestedScopes","type","collectScopes","uischema","scopes","currentPath","nestedScopeStack","seen","depthFirstSearch","getNeighbors","v","Array","isArray","map","s","i","entries","Object","idx","findIndex","tmp","enterVertex","currentVertex","key","push","scope","path","schemaPath","length","join","subscopes","buildScopeData","stackLength","leaveVertex","pop","allowTraversal","nextVertex","includes","validateScope","scopeData","schema","rootSchema","errors","e","message","dataPath","curSchema","startsWith","i18next","t","pointer","substr","tokens","jsonPointer","parse","isPropertiesKey","parentIsPropertiesKey","token","nextSchema","isPresent","compile","slice","items","validateUiSchemaScopes","dataSchema","a","dereferenceSchema","dereferencedSchema","yupLocaleTemplate","mixed","default","required","oneOf","notOneOf","notType","string","min","max","matches","email","url","trim","lowercase","uppercase","number","lessThan","moreThan","positive","negative","integer","date","object","noUnknown","array","buildLocale","locale","obj","result","setYupLocale","yup","defaultAcornOptions","ecmaVersion","iso8601Regex","identifierRegex","addYupErrors","errorInfos","basePath","inner","extractYupErrorMessages","validateWithYupSchema","options","validate","mergeDeepLeft","abortEarly","strict","then","catch","setupYup","language","on","this","test","paramNames","scriptKey","scriptContextKey","contextScript","context","undefined","createError","script","sourceType","toString","validateSchema","validateJsonSchema","isValidationFailure","mapAjvErrors","aggregate","compileSchema","JSON","error","jsonSchemaContextKey","jsonSchema","definition","definitions","name","addJsonSchemaValidators","json","einfos","addJsonValidators","validateUiSchema","addUiSchemaValidators","validateUiSchemaLibrary","addUiSchemaLibraryValidators","list","dups","forEach","item","j","params","duplicates","uniq","fn","itemValue","fieldNames","some","val","defaultedMsg","depthFirstSearchRecursive","previousVertex","callbacks","call","startVertex","allowTraversalCallbackGenerator","initCallbacks","detectCycle","cycle","visited","clone","getStronglyConnectedComponents","adjList","numVertices","index","repeat","lowValue","active","child","scc","sccLinks","times","count","components","sccAdjList","strongConnect","S","T","u","Math","component","links","linkCount","w","allLinks","sort","adjacencyList","ensureProperBasePath","str","getBasePath","memoizeWith","htmlBase","document","getElementsByTagName","getAttribute","schemas","contextTypeSchema","simulationStateSchema","uiSchemaSchema","uiSchemaLibrarySchema","widgetDefinitionSchema","dashboardDefinitionSchema","recognizedImageBatchSchema","schemaMap","mapObjIndexed","groupBy","$id","resolve","nimflow","order","canRead","file","read","omit","$RefParser","dereference","initPromise","currenti18nLanguage","atom","initializeI18n","i18n","use","HttpApi","LanguageDetector","initReactI18next","init","fallbackLng","detection","caches","backend","loadPath","interpolation","escapeValue","formatSeparator","mapper","mapper_en","setLanguage","lang","indexOf","substring","ajv","Ajv","allErrors","addUsedSchema","addFormats","addKeyword","keyword","schemaType","valid","addSchema","validator","data","dataCxt","schemaKeyRef","translateValidationErrors","validateContextTypeSchema","validateSimulationStateSchema","validateWidgetDefinitionSchema","validateDashboardDefinitionSchema","webpackAsyncContext","req","__webpack_require__","o","Promise","code","ids","id","all","keys","module","exports","Boolean","window","location","hostname","match","promise","setAutoFreeze","ReactDOM","render","getElementById","finally","navigator","serviceWorker","ready","registration","unregister","console","importSuccess","importFailure","instancePath"],"mappings":"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","file":"static/js/main.6a04bcb4.chunk.js","sourcesContent":["import env from \"@beam-australia/react-env\";\r\n\r\nexport const publicUrl = process.env.PUBLIC_URL;\r\n\r\nconst _businessDirectoryServerUrl = env(\"NIMFLOW_BUSINESS_DIRECTORY_SERVER_URL\");\r\n\r\nif (!_businessDirectoryServerUrl) {\r\n    throw new Error(\"Environment variable REACT_APP_NIMFLOW_BUSINESS_DIRECTORY_SERVER_URL not configured\");\r\n}\r\n\r\nexport const businessDirectoryServerUrl = _businessDirectoryServerUrl; \r\n\r\nexport const auth0Domain = env(\"AUTH0_DOMAIN\");\r\nexport const auth0ClientId = env(\"AUTH0_CLIENT_ID\");\r\nexport const auth0Audience = env(\"AUTH0_AUDIENCE\");\r\n\r\nexport const enableContextTypeDiagram = env(\"NIMFLOW_ENABLE_CONTEXT_TYPE_DIAGRAM\");\r\nexport const enableContextTypeRecalculate = env(\"NIMFLOW_ENABLE_CONTEXT_TYPE_RECALCULATE\");\r\n\r\nexport const persistedConfigurationStorageKey = env(\"PERSISTENT_CONFIG_KEY\") ?? \"nimflowStudioConfiguration\";","import {JSONSchema7} from \"json-schema\";\r\nimport {UISchemaElement} from \"@jsonforms/core\";\r\nimport jsonPointer from \"json-pointer\";\r\nimport i18next from \"i18next\";\r\nimport {isPresent} from \"ts-is-present\";\r\n\r\nimport {ErrorInfo} from \"./../models/error-info\";\r\nimport {depthFirstSearch} from \"./graph-algorithms\";\r\nimport {dereferenceSchema} from \"../libs/json-schema-ref-parser\";\r\n\r\ninterface ScopeData {\r\n    scope: any;\r\n    schemaPath: string;\r\n    subscopes: ScopeData[];\r\n}\r\n\r\n//Assume any object containing a key \"scope\" is scopable.\r\nconst isScopable = (value: any): value is Record<string, any> => value && typeof value === \"object\" && \"scope\" in value;\r\nconst hasNestedScopes = (value: any) => isScopable(value) && (value.type === \"Control\" || value.type === \"Use\");\r\n\r\nconst buildScopeData = (scope: string, path: Array<string | number>) => {\r\n    const dataPath =\r\n        path\r\n            .map(s => {\r\n                if (typeof s === \"number\") {\r\n                    return `[${s}]`;\r\n                } else if (s.length > 0) {\r\n                    return `.${s}`;\r\n                }\r\n                return \"\";\r\n            })\r\n            .join(\"\") + \".scope\";\r\n    const result: ScopeData = {\r\n        scope,\r\n        schemaPath: dataPath,\r\n        subscopes: [],\r\n    };\r\n    return result;\r\n};\r\n\r\nconst collectScopes = (uischema: any) => {\r\n    const scopes: ScopeData[] = [];\r\n    const currentPath: Array<string | number> = [];\r\n    const nestedScopeStack: ScopeData[] = [];\r\n    const seen: any[] = [];\r\n\r\n    depthFirstSearch<[string | number, any]>([\"\", uischema as any], {\r\n        getNeighbors: v => {\r\n            const value = v[1];\r\n            if (Array.isArray(value)) {\r\n                return value.map((s, i) => [i, s]);\r\n            }\r\n            if (typeof value === \"object\" && value !== null) {\r\n                const entries = Object.entries(value);\r\n                //Always process \"type\" property first.\r\n                const idx = entries.findIndex(([key]) => key === \"type\");\r\n                if (idx > 0) {\r\n                    const tmp = entries[idx];\r\n                    entries[idx] = entries[0];\r\n                    entries[0] = tmp;\r\n                }\r\n                return entries;\r\n            }\r\n            return [];\r\n        },\r\n        enterVertex: ({currentVertex: [key, value]}) => {\r\n            currentPath.push(key);\r\n            if (isScopable(value)) {\r\n                const scope = buildScopeData(value.scope, currentPath);\r\n                if (hasNestedScopes(value)) {\r\n                    nestedScopeStack.push(scope);\r\n                }\r\n                const stackLength = nestedScopeStack.length;\r\n                const subscopes = stackLength > 1 ? nestedScopeStack[stackLength - 2].subscopes : scopes;\r\n                subscopes.push(scope);\r\n            }\r\n        },\r\n        leaveVertex: ({currentVertex: [, value]}) => {\r\n            if (hasNestedScopes(value)) {\r\n                nestedScopeStack.pop();\r\n            }\r\n            currentPath.pop();\r\n        },\r\n        allowTraversal: ({nextVertex: [key, value]}) => {\r\n            if (seen.includes(value)) {\r\n                return false;\r\n            }\r\n            seen.push(value);\r\n            return true;\r\n        },\r\n    });\r\n    return scopes;\r\n};\r\n\r\nconst validateScope = (\r\n    scopeData: ScopeData,\r\n    schema: JSONSchema7,\r\n    rootSchema: JSONSchema7,\r\n    errors: ErrorInfo[]\r\n) => {\r\n    const e = (message: string) => {\r\n        errors.push({\r\n            dataPath: scopeData.schemaPath,\r\n            message,\r\n        });\r\n    };\r\n\r\n    const scope = scopeData.scope;\r\n    if (typeof scope !== \"string\") {\r\n        e(i18next.t(\"UiSchemaScopesMustBeOfTypeString\"));\r\n        return;\r\n    }\r\n    if (scope.length === 0) {\r\n        e(i18next.t(\"UiSchemaScopesCannotBeEmpty\"));\r\n        return;\r\n    }\r\n\r\n    let curSchema = schema as any;\r\n    if (scope !== \"#\") {\r\n        if (!scope.startsWith(\"#/\")) {\r\n            e(i18next.t(\"UiSchemaScopesMustReferenceTheAssociatedSchema\"));\r\n            return;\r\n        }\r\n        // TODO: implements validation when using combinators (anyOf, allOf or oneOf) and additionalProperties.\r\n        const pointer = scope.substr(1);\r\n        const tokens = jsonPointer.parse(pointer);\r\n        let isPropertiesKey = false;\r\n        let parentIsPropertiesKey = false;\r\n        for (let i = 0; i < tokens.length; i++) {\r\n            const token = tokens[i];\r\n            const nextSchema = curSchema[token];\r\n            if (!isPresent(nextSchema)) {\r\n                return e(\r\n                    i18next.t(\"UiSchemaScopesWithInvalidPath\", {pointer: jsonPointer.compile(tokens.slice(0, i + 1))})\r\n                );\r\n            }\r\n            parentIsPropertiesKey = isPropertiesKey;\r\n            isPropertiesKey = !parentIsPropertiesKey && token === \"properties\";\r\n            curSchema = nextSchema;\r\n        }\r\n        if (!parentIsPropertiesKey) {\r\n            return e(i18next.t(\"UiSchemaScopesDoesNotPointToAProperty\", {pointer}));\r\n        }\r\n    }\r\n    if (curSchema.type === \"array\") {\r\n        curSchema = curSchema.items;\r\n    }\r\n    for (const subscope of scopeData.subscopes) {\r\n        validateScope(subscope, curSchema, rootSchema, errors);\r\n    }\r\n    return undefined;\r\n};\r\n\r\nexport const validateUiSchemaScopes = async (\r\n    uischema: UISchemaElement,\r\n    dataSchema: JSONSchema7\r\n): Promise<ErrorInfo[]> => {\r\n    const scopes = collectScopes(uischema);\r\n    const dereferencedSchema = await dereferenceSchema(dataSchema as any);\r\n    const errors: ErrorInfo[] = [];\r\n    for (const scope of scopes) {\r\n        validateScope(scope, dereferencedSchema, dereferencedSchema, errors);\r\n    }\r\n    return errors;\r\n};\r\n","import * as yup from \"yup\";\r\nimport i18next from \"i18next\";\r\nimport {uniq, mergeDeepLeft} from \"ramda\";\r\nimport {isPresent} from \"ts-is-present\";\r\nimport {parse, Options} from \"acorn\";\r\nimport {ValidateOptions, Message} from \"yup/lib/types\";\r\n\r\nimport {validateJsonSchema, isValidationFailure, validateUiSchema, validateUiSchemaLibrary, validate, compileSchema} from \"./ajv\";\r\nimport {ErrorInfo} from \"./../models/error-info\";\r\nimport {mapAjvErrors} from \"../models/importers\";\r\nimport {validateUiSchemaScopes} from \"../utils/uischema-scope-validator\";\r\n\r\n/*eslint-disable no-new-func*/\r\n\r\n//TODO: Evaluar migraciÃ³n a https://github.com/vriad/zod\r\n\r\nconst yupLocaleTemplate = {\r\n    mixed: {\r\n        default: \"\",\r\n        required: \"\",\r\n        oneOf: \"\",\r\n        notOneOf: \"\",\r\n        notType: \"\",\r\n        //\"defined\": \"\"\r\n    },\r\n    string: {\r\n        length: \"\",\r\n        min: \"\",\r\n        max: \"\",\r\n        matches: \"\",\r\n        email: \"\",\r\n        url: \"\",\r\n        //\"uuid\": \"\",\r\n        trim: \"\",\r\n        lowercase: \"\",\r\n        uppercase: \"\",\r\n    },\r\n    number: {\r\n        min: \"\",\r\n        max: \"\",\r\n        lessThan: \"\",\r\n        moreThan: \"\",\r\n        //\"notEqual\": \"\",\r\n        positive: \"\",\r\n        negative: \"\",\r\n        integer: \"\",\r\n    },\r\n    date: {\r\n        min: \"\",\r\n        max: \"\",\r\n    },\r\n    object: {\r\n        noUnknown: \"\",\r\n    },\r\n    array: {\r\n        min: \"\",\r\n        max: \"\",\r\n    },\r\n};\r\n\r\nconst buildLocale = (locale: string, obj: any, path: string[]): any => {\r\n    const result: any = {};\r\n    for (const [key, value] of Object.entries(obj)) {\r\n        if (typeof value === \"object\") {\r\n            path.push(key);\r\n            result[key] = buildLocale(locale, value, path);\r\n            path.pop();\r\n        } else {\r\n            result[key] = i18next.t(`${path.join(\".\")}.${key}`);\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nconst setYupLocale = (locale: string) => {\r\n    const result = buildLocale(locale, yupLocaleTemplate, [\"Yup\"]);\r\n    yup.setLocale(result);\r\n};\r\n\r\nconst defaultAcornOptions: Options = {\r\n    ecmaVersion: 2020,\r\n};\r\n\r\nconst addJavascriptValidators = () => {\r\n    yup.addMethod<yup.StringSchema>(\r\n        yup.string,\r\n        \"jsExpression\",\r\n        function (options?: {paramNames?: string[]; scriptContextKey?: string}) {\r\n            return this.test({\r\n                test: function (value) {\r\n                    if (typeof value === \"string\" && value.length > 0) {\r\n                        try {\r\n                            const paramNames = [\"common\"];\r\n                            if (options?.paramNames) {\r\n                                paramNames.push(...options.paramNames);\r\n                            }\r\n                            const scriptKey = options?.scriptContextKey;\r\n                            let contextScript = scriptKey ? (this.options.context as any)?.[scriptKey] : undefined;\r\n                            if (typeof contextScript === \"function\") {\r\n                                contextScript = contextScript();\r\n                            }\r\n                            if (scriptKey && contextScript && typeof contextScript !== \"string\") {\r\n                                return this.createError({\r\n                                    path: this.path,\r\n                                    message: `Yup context key '${scriptKey}' was expected to be of type string (or a function returning a string) but was ${typeof contextScript}`,\r\n                                });\r\n                            }\r\n                            const script = `\r\n                            function dummyfn(${paramNames.join(\", \")}) {\r\n                                return ${value};\r\n                            };\r\n                        `;\r\n                            parse(script, {\r\n                                ...defaultAcornOptions,\r\n                                sourceType: \"script\",\r\n                            });\r\n                        } catch (e: any) {\r\n                            return this.createError({\r\n                                path: this.path,\r\n                                message: e.toString(),\r\n                            });\r\n                        }\r\n                    }\r\n                    return true;\r\n                },\r\n            });\r\n        }\r\n    );\r\n\r\n    yup.addMethod<yup.StringSchema>(yup.string, \"jsScript\", function (...paramNames: string[]) {\r\n        return this.test({\r\n            test: function (value) {\r\n                if (typeof value === \"string\" && value.length > 0) {\r\n                    try {\r\n                        const script = `\r\n                            function dummyfn(${paramNames.join(\", \")}) {\r\n                                ${value}\r\n                            };\r\n                        `;\r\n                        parse(script, {\r\n                            ...defaultAcornOptions,\r\n                            sourceType: \"script\",\r\n                        });\r\n                    } catch (e: any) {\r\n                        return this.createError({\r\n                            path: this.path,\r\n                            message: e.toString(),\r\n                        });\r\n                    }\r\n                }\r\n                return true;\r\n            },\r\n        });\r\n    });\r\n\r\n    yup.addMethod<yup.StringSchema>(yup.string, \"jsModule\", function () {\r\n        return this.test({\r\n            test: function (value) {\r\n                if (typeof value === \"string\" && value.length > 0) {\r\n                    try {\r\n                        parse(value, {\r\n                            ...defaultAcornOptions,\r\n                            sourceType: \"module\",\r\n                        });\r\n                    } catch (e: any) {\r\n                        return this.createError({\r\n                            path: this.path,\r\n                            message: e.toString(),\r\n                        });\r\n                    }\r\n                }\r\n                return true;\r\n            },\r\n        });\r\n    });\r\n};\r\n\r\nconst addJsonValidators = () => {\r\n    const validateSchema = async (json: any, jsonSchemaContextKey: string, context: yup.TestContext) => {\r\n        let jsonSchema = (context.options.context as any)?.[jsonSchemaContextKey];\r\n        if (typeof jsonSchema === \"function\") {\r\n            jsonSchema = jsonSchema();\r\n        }\r\n        if (typeof jsonSchema === \"string\") {\r\n            jsonSchema = JSON.parse(jsonSchema);\r\n        }\r\n\r\n        if (jsonSchema) {\r\n            const result = validate(jsonSchema, json);\r\n            if (isValidationFailure(result)) {\r\n                const einfos = mapAjvErrors(result.errors);\r\n                if (einfos.length > 0) {\r\n                    const errors = einfos.map(e => {\r\n                        return context.createError({\r\n                            path: context.path,\r\n                            message: e.dataPath + \" - \" + e.message,\r\n                        });\r\n                    });\r\n                    const aggregate = context.createError();\r\n                    aggregate.inner = errors;\r\n                    return aggregate;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n\r\n    yup.addMethod<yup.ObjectSchema<any>>(yup.object, \"json\", function (jsonSchemaContextKey: string) {\r\n        return this.test({\r\n            test: async function (value) {\r\n                if (typeof value === \"object\") {\r\n                    return await validateSchema(value, jsonSchemaContextKey, this);\r\n                }\r\n                return true;\r\n            },\r\n        });\r\n    });\r\n\r\n    yup.addMethod<yup.StringSchema>(yup.string, \"json\", function (jsonSchemaContextKey: string) {\r\n        return this.test({\r\n            test: async function (value) {\r\n                if (typeof value === \"string\" && value) {\r\n                    let json: any;\r\n                    try {\r\n                        json = JSON.parse(value);\r\n                    } catch (error: any) {\r\n                        return this.createError({\r\n                            path: this.path,\r\n                            message: error.toString(),\r\n                        });\r\n                    }\r\n                    return await validateSchema(json, jsonSchemaContextKey, this);\r\n                }\r\n                return true;\r\n            },\r\n        });\r\n    });\r\n};\r\n\r\nconst addJsonSchemaValidators = () => {\r\n    const validateSchema = (schema: object, context: yup.TestContext) => {\r\n        try {\r\n            const result = validateJsonSchema(schema);\r\n            if (isValidationFailure(result)) {\r\n                const errors = mapAjvErrors(result.errors).map(e => {\r\n                    return context.createError({\r\n                        path: context.path,\r\n                        message: e.dataPath + \" - \" + e.message,\r\n                    });\r\n                });\r\n                const aggregate = context.createError();\r\n                aggregate.inner = errors;\r\n                return aggregate;\r\n            } else {\r\n                compileSchema(schema, false);\r\n            }\r\n            return true;\r\n        } catch (e: any) {\r\n            return context.createError({\r\n                path: context.path,\r\n                message: e.message,\r\n            });\r\n}\r\n    };\r\n\r\n    yup.addMethod<yup.ObjectSchema<any>>(yup.object, \"jsonSchema\", function () {\r\n        return this.test({\r\n            test: function (value) {\r\n                if (typeof value === \"object\") {\r\n                    return validateSchema(value, this);\r\n                }\r\n                return true;\r\n            },\r\n        });\r\n    });\r\n\r\n    yup.addMethod<yup.StringSchema>(yup.string, \"jsonSchema\", function () {\r\n        return this.test({\r\n            test: function (value) {\r\n                if (typeof value === \"string\" && value) {\r\n                    let schema: any;\r\n                    try {\r\n                        schema = JSON.parse(value);\r\n                    } catch (error: any) {\r\n                        return this.createError({\r\n                            path: this.path,\r\n                            message: error.toString(),\r\n                        });\r\n                    }\r\n                    return validateSchema(schema, this);\r\n                }\r\n                return true;\r\n            },\r\n        });\r\n    });\r\n\r\n    yup.addMethod<yup.StringSchema>(yup.string, \"jsonSchemaDefinitionName\", function (jsonSchemaContextKey: string) {\r\n        return this.test({\r\n            test: function (value) {\r\n                if (jsonSchemaContextKey && typeof value === \"string\" && value.length > 0) {\r\n                    try {\r\n                        let jsonSchema = (this.options.context as any)?.[jsonSchemaContextKey];\r\n                        if (typeof jsonSchema === \"function\") {\r\n                            jsonSchema = jsonSchema();\r\n                        }\r\n                        if (typeof jsonSchema === \"string\") {\r\n                            jsonSchema = JSON.parse(jsonSchema);\r\n                        }\r\n                        if (jsonSchema && typeof jsonSchema !== \"object\") {\r\n                            return this.createError({\r\n                                path: this.path,\r\n                                message: `Yup context key '${jsonSchemaContextKey}' does not reference a valid json schema or a function returning one`,\r\n                            });\r\n                        }\r\n                        const definition = jsonSchema.definitions?.[value];\r\n                        if (typeof definition === \"boolean\") {\r\n                            return true;\r\n                        }\r\n                        if (!isPresent(definition)) {\r\n                            return this.createError({\r\n                                path: this.path,\r\n                                message: i18next.t(\"NoDefinitionInSchema\", {name: value}),\r\n                            });\r\n                        }\r\n                        if (typeof definition !== \"object\") {\r\n                            return this.createError({\r\n                                path: this.path,\r\n                                message: `Json Schema definition '${value}' was expected to be of type object or boolean but was ${typeof jsonSchema}`,\r\n                            });\r\n                        }\r\n                    } catch (e: any) {\r\n                        return this.createError({\r\n                            path: this.path,\r\n                            message: e.toString(),\r\n                        });\r\n                    }\r\n                }\r\n                return true;\r\n            },\r\n        });\r\n    });\r\n};\r\n\r\nconst addUiSchemaValidators = () => {\r\n    const validateSchema = async (schema: any, jsonSchemaContextKey: string, context: yup.TestContext) => {\r\n        const result = validateUiSchema(schema);\r\n        const einfos: ErrorInfo[] = [];\r\n        if (isValidationFailure(result)) {\r\n            einfos.push(...mapAjvErrors(result.errors));\r\n        }\r\n        let jsonSchema = (context.options.context as any)?.[jsonSchemaContextKey];\r\n        if (typeof jsonSchema === \"function\") {\r\n            jsonSchema = jsonSchema();\r\n        }\r\n        if (typeof jsonSchema === \"string\") {\r\n            jsonSchema = JSON.parse(jsonSchema);\r\n        }\r\n\r\n        if (jsonSchema) {\r\n            try {\r\n                einfos.push(...(await validateUiSchemaScopes(schema, jsonSchema)));\r\n            } catch (e: any) {\r\n                if (einfos.length === 0) {\r\n                    // Priorize schema errors.\r\n                    return context.createError({\r\n                        path: context.path,\r\n                        message: e.toString(),\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        if (einfos.length > 0) {\r\n            const errors = einfos.map(e => {\r\n                return context.createError({\r\n                    path: context.path,\r\n                    message: e.dataPath + \" - \" + e.message,\r\n                });\r\n            });\r\n            const aggregate = context.createError();\r\n            aggregate.inner = errors;\r\n            return aggregate;\r\n        }\r\n        return true;\r\n    };\r\n\r\n    yup.addMethod<yup.ObjectSchema<any>>(yup.object, \"uiSchema\", function (jsonSchemaContextKey: string) {\r\n        return this.test({\r\n            test: async function (value) {\r\n                if (typeof value === \"object\") {\r\n                    return await validateSchema(value, jsonSchemaContextKey, this);\r\n                }\r\n                return true;\r\n            },\r\n        });\r\n    });\r\n\r\n    yup.addMethod<yup.StringSchema>(yup.string, \"uiSchema\", function (jsonSchemaContextKey: string) {\r\n        return this.test({\r\n            test: async function (value) {\r\n                if (typeof value === \"string\" && value) {\r\n                    let schema: any;\r\n                    try {\r\n                        schema = JSON.parse(value);\r\n                    } catch (error: any) {\r\n                        return this.createError({\r\n                            path: this.path,\r\n                            message: error.toString(),\r\n                        });\r\n                    }\r\n                    return await validateSchema(schema, jsonSchemaContextKey, this);\r\n                }\r\n                return true;\r\n            },\r\n        });\r\n    });\r\n};\r\n\r\nconst addUiSchemaLibraryValidators = () => {\r\n    const validateSchema = async (schema: any, jsonSchemaContextKey: string, context: yup.TestContext) => {\r\n        const result = validateUiSchemaLibrary(schema);\r\n        const einfos: ErrorInfo[] = [];\r\n        if (isValidationFailure(result)) {\r\n            einfos.push(...mapAjvErrors(result.errors));\r\n        }\r\n        let jsonSchema = (context.options.context as any)?.[jsonSchemaContextKey];\r\n        if (typeof jsonSchema === \"function\") {\r\n            jsonSchema = jsonSchema();\r\n        }\r\n        if (typeof jsonSchema === \"string\") {\r\n            jsonSchema = JSON.parse(jsonSchema);\r\n        }\r\n\r\n        if (jsonSchema) {\r\n            try {\r\n                einfos.push(...(await validateUiSchemaScopes(schema, jsonSchema)));\r\n            } catch (e: any) {\r\n                if (einfos.length === 0) {\r\n                    // Priorize schema errors.\r\n                    return context.createError({\r\n                        path: context.path,\r\n                        message: e.toString(),\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        if (einfos.length > 0) {\r\n            const errors = einfos.map(e => {\r\n                return context.createError({\r\n                    path: context.path,\r\n                    message: e.dataPath + \" - \" + e.message,\r\n                });\r\n            });\r\n            const aggregate = context.createError();\r\n            aggregate.inner = errors;\r\n            return aggregate;\r\n        }\r\n        return true;\r\n    };\r\n\r\n    yup.addMethod<yup.ObjectSchema<any>>(yup.object, \"uiSchemaLibrary\", function (jsonSchemaContextKey: string) {\r\n        return this.test({\r\n            test: async function (value) {\r\n                if (typeof value === \"object\") {\r\n                    return await validateSchema(value, jsonSchemaContextKey, this);\r\n                }\r\n                return true;\r\n            },\r\n        });\r\n    });\r\n\r\n    yup.addMethod<yup.StringSchema>(yup.string, \"uiSchemaLibrary\", function (jsonSchemaContextKey: string) {\r\n        return this.test({\r\n            test: async function (value) {\r\n                if (typeof value === \"string\" && value) {\r\n                    let schema: any;\r\n                    try {\r\n                        schema = JSON.parse(value);\r\n                    } catch (error: any) {\r\n                        return this.createError({\r\n                            path: this.path,\r\n                            message: error.toString(),\r\n                        });\r\n                    }\r\n                    return await validateSchema(schema, jsonSchemaContextKey, this);\r\n                }\r\n                return true;\r\n            },\r\n        });\r\n    });\r\n};\r\n\r\nconst addArrayUniquenessValidators = () => {\r\n    yup.addMethod<yup.ArraySchema<any>>(yup.array, \"unique\", function (message: Message<{duplicates: any[]}>) {\r\n        return this.test(\"unique\", \"\", function (value: any) {\r\n            const list = value as any[];\r\n            if (!list || list.length === 0) {\r\n                return true;\r\n            }\r\n            const dups: any[] = [];\r\n            list.forEach((item, i) => {\r\n                for (let j = i + 1; j < list.length; j++) {\r\n                    if (item === list[j]) {\r\n                        dups.push(item);\r\n                    }\r\n                }\r\n            });\r\n            if (dups.length > 0) {\r\n                return this.createError({path: this.path, message, params: {duplicates: uniq(dups)}});\r\n            }\r\n            return true;\r\n        });\r\n    });\r\n    yup.addMethod<yup.ArraySchema<any>>(\r\n        yup.array,\r\n        \"uniqueBy\",\r\n        function (fn: (value: any) => any, message: Message<{duplicates: any[]}>) {\r\n            return this.test(\"uniqueBy\", \"\", function (value: any) {\r\n                const list = value as any[];\r\n                if (!list || list.length === 0) {\r\n                    return true;\r\n                }\r\n                const dups: any[] = [];\r\n                list.forEach((item, i) => {\r\n                    const itemValue = fn(item);\r\n                    for (let j = i + 1; j < list.length; j++) {\r\n                        const testValue = fn(list[j]);\r\n                        if (itemValue === testValue) {\r\n                            dups.push(itemValue);\r\n                        }\r\n                    }\r\n                });\r\n                if (dups.length > 0) {\r\n                    return this.createError({path: this.path, message, params: {duplicates: uniq(dups)}});\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n    );\r\n};\r\n\r\nconst addAtLeastOneRequired = () => {\r\n    yup.addMethod<yup.ObjectSchema<any>>(\r\n        yup.object,\r\n        \"atLeastOneRequired\",\r\n        function (fieldNames: string[], message?: Message) {\r\n            message = message ?? i18next.t(\"AtLeastOneRequired\", {fieldNames: fieldNames.join(\", \")}) ?? \"\";\r\n            return this.test(\"atLeastOneRequired\", message, function (obj: any) {\r\n                if (!fieldNames || fieldNames.length === 0) {\r\n                    return true;\r\n                }\r\n                if (!isPresent(obj)) {\r\n                    return false;\r\n                }\r\n                if (fieldNames.some(s => isPresent(obj[s]))) {\r\n                    return true;\r\n                }\r\n                return this.createError({\r\n                    path: this.path ? `${this.path}.${fieldNames[0]}` : fieldNames[0],\r\n                    message: i18next.t(\"AtLeastOneRequired\", {fieldNames: fieldNames.join(\", \")}),\r\n                });\r\n            });\r\n        }\r\n    );\r\n};\r\n\r\nconst addWithLocalContext = () => {\r\n    yup.addMethod<yup.BaseSchema<any>>(\r\n        yup.mixed,\r\n        \"withLocalContext\",\r\n        function (fn: (schema: yup.BaseSchema<any>) => yup.BaseSchema<any>) {\r\n            return fn(this);\r\n        }\r\n    );\r\n};\r\n\r\nconst iso8601Regex =\r\n    /^(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(.[0-9]+)?(Z|[+-][01][0-9]:[0-9][0-9])?$/;\r\n\r\nconst addIso8601FormattedString = () => {\r\n    yup.addMethod<yup.StringSchema>(yup.string, \"iso8601Formatted\", function (message?: Message<{value: string}>) {\r\n        return this.test(\"iso8601Formatted\", \"\", function (val: any) {\r\n            const value = val as string;\r\n            if (!value) {\r\n                return true;\r\n            }\r\n            if (!iso8601Regex.test(value)) {\r\n                const defaultedMsg = (message =\r\n                    message ?? i18next.t(\"ValueDoesNotComplyWithIso8601DateTimeStandard\", {value}) ?? \"\");\r\n                return this.createError({path: this.path, message: defaultedMsg});\r\n            }\r\n            return true;\r\n        });\r\n    });\r\n};\r\n\r\nconst identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_-]*$/;\r\n\r\nconst addIdentifier = () => {\r\n    yup.addMethod<yup.StringSchema>(yup.string, \"identifier\", function (message?: Message<{value: string}>) {\r\n        return this.test(\"identifier\", \"\", function (val: any) {\r\n            const value = val as string;\r\n            if (!value) {\r\n                return true;\r\n            }\r\n            if (!identifierRegex.test(value)) {\r\n                const defaultedMsg = message ?? i18next.t(\"ValueIsNotAnIdentifier\", {value}) ?? \"\";\r\n                return this.createError({path: this.path, message: defaultedMsg});\r\n            }\r\n            return true;\r\n        });\r\n    });\r\n};\r\n\r\nconst addYupErrors = (errors: yup.ValidationError[], errorInfos: ErrorInfo[], basePath?: string) => {\r\n    for (const e of errors) {\r\n        if (e.inner && e.inner.length > 0) {\r\n            addYupErrors(e.inner, errorInfos, basePath);\r\n        } else {\r\n            errorInfos.push({dataPath: (basePath ?? \"\") + (e.path ?? \"\"), message: e.message});\r\n        }\r\n        /*if (e.inner && e.inner.length > 0) {\r\n            addYupErrors(e.inner, messages, basePath);\r\n        }*/\r\n    }\r\n};\r\n\r\nexport const extractYupErrorMessages = (\r\n    errors: yup.ValidationError | yup.ValidationError[],\r\n    basePath?: string\r\n): ErrorInfo[] => {\r\n    const result: ErrorInfo[] = [];\r\n    errors = Array.isArray(errors) ? errors : [errors];\r\n    addYupErrors(errors, result, basePath);\r\n    return result;\r\n};\r\n\r\nexport const validateWithYupSchema = async (\r\n    schema: yup.BaseSchema<any> | undefined,\r\n    value: any,\r\n    options?: ValidateOptions<any>\r\n): Promise<ErrorInfo[]> => {\r\n    if (!schema) {\r\n        return [] as ErrorInfo[];\r\n    }\r\n    const result = await schema\r\n        .validate(value, mergeDeepLeft(options ?? {}, {abortEarly: false, strict: true}))\r\n        .then(() => [] as ErrorInfo[])\r\n        .catch((e: yup.ValidationError) => {\r\n            return extractYupErrorMessages(e);\r\n        });\r\n    return result;\r\n};\r\n\r\nexport const setupYup = () => {\r\n    setYupLocale(i18next.language);\r\n    i18next.on(\"languageChanged\", s => setYupLocale(s));\r\n    addJavascriptValidators();\r\n    addJsonSchemaValidators();\r\n    addJsonValidators();\r\n    addUiSchemaValidators();\r\n    addUiSchemaLibraryValidators();\r\n    addArrayUniquenessValidators();\r\n    addAtLeastOneRequired();\r\n    addWithLocalContext();\r\n    addIso8601FormattedString();\r\n    addIdentifier();\r\n};\r\n","import {clone, repeat, times, uniq} from \"ramda\";\r\n\r\ninterface DepthFirstCallbacks<V> {\r\n    enterVertex?: (args: {currentVertex: V; previousVertex?: V}) => void;\r\n    leaveVertex?: (args: {currentVertex: V; previousVertex?: V}) => void;\r\n    allowTraversal?: (args: {currentVertex: V; previousVertex?: V; nextVertex: V}) => boolean;\r\n    getNeighbors: (currentVertex: V) => V[];\r\n}\r\n\r\nfunction initCallbacks<V>(callbacks: DepthFirstCallbacks<V>) {\r\n    const allowTraversalCallbackGenerator = () => {\r\n        const seen: V[] = [];\r\n        return ({nextVertex}: {nextVertex: V}) => {\r\n            if (!seen.includes(nextVertex)) {\r\n                seen.push(nextVertex);\r\n                return true;\r\n            }\r\n            return false;\r\n        };\r\n    };\r\n\r\n    return {\r\n        ...callbacks,\r\n        allowTraversal: callbacks.allowTraversal ?? allowTraversalCallbackGenerator(),\r\n    };\r\n}\r\nfunction depthFirstSearchRecursive<V>(\r\n    currentVertex: V,\r\n    previousVertex: V | undefined,\r\n    callbacks: DepthFirstCallbacks<V>\r\n) {\r\n    callbacks.enterVertex?.({currentVertex, previousVertex});\r\n    for (const nextVertex of callbacks.getNeighbors(currentVertex)) {\r\n        if (callbacks.allowTraversal!({previousVertex, currentVertex, nextVertex})) {\r\n            depthFirstSearchRecursive(nextVertex, currentVertex, callbacks);\r\n        }\r\n    }\r\n    callbacks.leaveVertex?.({currentVertex, previousVertex});\r\n}\r\n\r\nexport function depthFirstSearch<V>(startVertex: V, callbacks: DepthFirstCallbacks<V>) {\r\n    depthFirstSearchRecursive(startVertex, undefined, initCallbacks(callbacks));\r\n}\r\n\r\ninterface FindCycleCallbacks<V> {\r\n    getNeighbors: (currentVertex: V) => V[];\r\n}\r\n\r\nexport function detectCycle<V>(startVertex: V, callbacks: FindCycleCallbacks<V>): V[] | undefined {\r\n    const visited: V[] = [];\r\n    let cycle: V[] | undefined;\r\n    depthFirstSearch(startVertex, {\r\n        getNeighbors: callbacks.getNeighbors,\r\n        enterVertex: ({currentVertex: v}) => {\r\n            if (visited.includes(v)) {\r\n                cycle = clone(visited);\r\n            }\r\n            visited.push(v);\r\n        },\r\n        leaveVertex: () => {\r\n            visited.pop();\r\n        },\r\n        allowTraversal: () => !cycle,\r\n    });\r\n    return cycle;\r\n}\r\n\r\n// Tarjan's strongly connected components algorithm (https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm)\r\nexport function getStronglyConnectedComponents(adjList: number[][]) {\r\n    const numVertices = adjList.length;\r\n    const index = repeat(-1, numVertices);\r\n    const lowValue = repeat(0, numVertices);\r\n    const active = repeat(false, numVertices);\r\n    const child = repeat(0, numVertices);\r\n    const scc = repeat(-1, numVertices);\r\n    const sccLinks = times((): number[] => [], numVertices);\r\n\r\n    // The strongConnect function\r\n    let count = 0;\r\n    const components: number[][] = [];\r\n    const sccAdjList: number[][] = [];\r\n\r\n    function strongConnect(v: number) {\r\n        // To avoid running out of stack space, this emulates the recursive behaviour of the normal algorithm, effectively using T as the call stack.\r\n        const S: number[] = [v],\r\n            T: number[] = [v];\r\n        index[v] = lowValue[v] = count;\r\n        active[v] = true;\r\n        count += 1;\r\n        while (T.length > 0) {\r\n            v = T[T.length - 1];\r\n            const e = adjList[v];\r\n            if (child[v] < e.length) {\r\n                // If we're not done iterating over the children, first try finishing that.\r\n                let i = child[v];\r\n                for (; i < e.length; ++i) {\r\n                    // Start where we left off.\r\n                    const u = e[i];\r\n                    if (index[u] < 0) {\r\n                        index[u] = lowValue[u] = count;\r\n                        active[u] = true;\r\n                        count += 1;\r\n                        S.push(u);\r\n                        T.push(u);\r\n                        break; // First recurse, then continue here (with the same child!).\r\n                        // There is a slight change to Tarjan's algorithm here.\r\n                        // Normally, after having recursed, we set lowValue like we do for an active child (although some variants of the algorithm do it slightly differently).\r\n                        // Here, we only do so if the child we recursed on is still active.\r\n                        // The reasoning is that if it is no longer active, it must have had a lowValue equal to its own index, which means that it is necessarily higher than our lowValue.\r\n                    } else if (active[u]) {\r\n                        lowValue[v] = Math.min(lowValue[v], lowValue[u]) | 0;\r\n                    }\r\n                    if (scc[u] >= 0) {\r\n                        // Node v is not yet assigned an scc, but once it is that scc can apparently reach scc[u].\r\n                        sccLinks[v].push(scc[u]);\r\n                    }\r\n                }\r\n                child[v] = i; // Remember where we left off.\r\n            } else {\r\n                // If we're done iterating over the children, check whether we have an scc.\r\n                if (lowValue[v] === index[v]) {\r\n                    // TODO: It /might/ be true that T is always a prefix of S (at this point!!!), and if so, this could be used here.\r\n                    const component: number[] = [];\r\n                    const links: number[][] = [];\r\n                    let linkCount = 0;\r\n                    for (let i = S.length - 1; i >= 0; --i) {\r\n                        const w = S[i];\r\n                        active[w] = false;\r\n                        component.push(w);\r\n                        links.push(sccLinks[w]);\r\n                        linkCount += sccLinks[w].length;\r\n                        scc[w] = components.length;\r\n                        if (w === v) {\r\n                            S.length = i;\r\n                            break;\r\n                        }\r\n                    }\r\n                    components.push(component);\r\n                    const allLinks = new Array(linkCount);\r\n                    for (let i = 0; i < links.length; i++) {\r\n                        for (let j = 0; j < links[i].length; j++) {\r\n                            allLinks[--linkCount] = links[i][j];\r\n                        }\r\n                    }\r\n                    sccAdjList.push(allLinks);\r\n                }\r\n                T.pop(); // Now we're finished exploring this particular node (normally corresponds to the return statement)\r\n            }\r\n        }\r\n    }\r\n\r\n    //Run strong connect starting from each vertex\r\n    for (let i = 0; i < numVertices; ++i) {\r\n        if (index[i] < 0) {\r\n            strongConnect(i);\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < sccAdjList.length; i++) {\r\n        const e = sccAdjList[i];\r\n        if (e.length > 0) {\r\n            sccAdjList[i] = uniq(e).sort();\r\n        }\r\n    }\r\n\r\n    return {components: components, adjacencyList: sccAdjList};\r\n}\r\n","import {memoizeWith} from \"ramda\";\r\n\r\nimport {publicUrl} from \"../env-vars\";\r\n\r\nconst ensureProperBasePath = (str: string) => {\r\n    if (str.length === 0 || str[0] !== \"/\") {\r\n        str = \"/\" + str;\r\n    }\r\n    if (str.length > 1 && str[str.length - 1] === \"/\") {\r\n        str = str.substr(0, str.length - 1);\r\n    }\r\n    return str;\r\n};\r\n\r\nexport const getBasePath = memoizeWith(\r\n    () => \"baseUrl\",\r\n    () => {\r\n        const htmlBase = document.getElementsByTagName(\"base\")[0]?.getAttribute(\"href\");\r\n        if (htmlBase) {\r\n            return ensureProperBasePath(htmlBase);\r\n        }\r\n        if (publicUrl) {\r\n            return ensureProperBasePath(publicUrl);\r\n        }\r\n        return \"/\";\r\n    }\r\n);\r\n","import {groupBy, omit} from \"ramda\";\r\nimport $RefParser, {ResolverOptions} from \"@apidevtools/json-schema-ref-parser\";\r\nimport {JSONSchema7} from \"json-schema\";\r\nimport {mapObjIndexed} from \"ramda\";\r\n\r\nimport contextTypeSchema from \"../schemas/context-type.schema.json\";\r\nimport simulationStateSchema from \"../schemas/simulation-state.schema.json\";\r\nimport uiSchemaSchema from \"../schemas/ui-schema.schema.json\";\r\nimport uiSchemaLibrarySchema from \"../schemas/ui-schema-library.schema.json\";\r\nimport widgetDefinitionSchema from \"../schemas/widget-definition.schema.json\";\r\nimport dashboardDefinitionSchema from \"../schemas/dashboard-definition.schema.json\";\r\nimport recognizedImageBatchSchema from \"../schemas/recognized-image-batch.schema.json\";\r\n\r\nconst schemas = [\r\n    contextTypeSchema,\r\n    simulationStateSchema,\r\n    uiSchemaSchema,\r\n    uiSchemaLibrarySchema,\r\n    widgetDefinitionSchema,\r\n    dashboardDefinitionSchema,\r\n    recognizedImageBatchSchema,\r\n] as JSONSchema7[];\r\n\r\nconst schemaMap = mapObjIndexed(\r\n    (s: JSONSchema7[]) => s[0],\r\n    groupBy(s => s.$id!, schemas)\r\n);\r\n\r\nconst resolver: Partial<ResolverOptions> = {\r\n    order: 1,\r\n    canRead: file => {\r\n        return !!schemaMap[file.url];\r\n    },\r\n    read: file => {\r\n        return omit([/*\"$schema\",*/ \"$id\"], schemaMap[file.url]);\r\n    },\r\n};\r\n\r\nconst options: $RefParser.Options = {\r\n    resolve: {\r\n        nimflow: resolver,\r\n    },\r\n};\r\n\r\nexport const dereferenceSchema = (schema: string | JSONSchema7): Promise<JSONSchema7> => {\r\n    return $RefParser.dereference(schema, options) as Promise<JSONSchema7>;\r\n};\r\n","import i18n, {TFunction} from \"i18next\";\r\nimport {initReactI18next} from \"react-i18next\";\r\nimport LanguageDetector from \"i18next-browser-languagedetector\";\r\nimport HttpApi from \"i18next-http-backend\";\r\nimport {atom} from \"recoil\";\r\n\r\nimport {getBasePath} from \"../utils/get-base-url\";\r\n\r\nlet initPromise: Promise<TFunction> | undefined = undefined;\r\n\r\nexport const currenti18nLanguage = atom<string | undefined>({\r\n    key: \"currenti18nLanguage\",\r\n    default: undefined,\r\n});\r\n\r\nexport const initializeI18n = () => {\r\n    if (!initPromise) {\r\n        let basePath = getBasePath();\r\n        if (basePath.length > 0 && basePath[basePath.length - 1] !== \"/\") {\r\n            basePath += \"/\";\r\n        }\r\n        initPromise = i18n\r\n            .use(HttpApi)\r\n            .use(LanguageDetector)\r\n            .use(initReactI18next)\r\n            .init({\r\n                fallbackLng: \"en\",\r\n                //debug: true,\r\n                detection: {\r\n                    caches: [],\r\n                },\r\n                //keySeparator: false, // we do not use keys in form messages.welcome\r\n                backend: {\r\n                    loadPath: basePath + \"i18n/{{lng}}.json\",\r\n                },\r\n                interpolation: {\r\n                    escapeValue: false, // react already prevents xss\r\n                    formatSeparator: \",\",\r\n                },\r\n            });\r\n    }\r\n    return initPromise;\r\n};\r\n","import Ajv, {ErrorObject} from \"ajv\";\r\nimport addFormats from \"ajv-formats\";\r\nimport {DataValidationCxt} from \"ajv/dist/types\";\r\nimport mapper_en from \"ajv-i18n/localize/en\";\r\nimport i18next from \"i18next\";\r\n\r\nimport contextTypeSchema from \"../schemas/context-type.schema.json\";\r\nimport simulationStateSchema from \"../schemas/simulation-state.schema.json\";\r\nimport uiSchemaSchema from \"../schemas/ui-schema.schema.json\";\r\nimport uiSchemaLibrarySchema from \"../schemas/ui-schema-library.schema.json\";\r\nimport widgetDefinitionSchema from \"../schemas/widget-definition.schema.json\";\r\nimport dashboardDefinitionSchema from \"../schemas/dashboard-definition.schema.json\";\r\nimport recognizedImageBatchSchema from \"../schemas/recognized-image-batch.schema.json\";\r\n\r\nlet mapper = mapper_en;\r\n\r\nfunction setLanguage(lang: string) {\r\n    import(`ajv-i18n/localize/${lang}/index`)\r\n        .then(s => {\r\n            if (typeof s?.default === \"function\") {\r\n                mapper = s.default;\r\n            }\r\n        })\r\n        .catch(() => {\r\n            const idx = lang.indexOf(\"-\");\r\n            if (idx > 0) {\r\n                setLanguage(lang.substring(0, idx));\r\n            }\r\n        });\r\n}\r\n\r\nif (i18next.language) {\r\n    setLanguage(i18next.language);\r\n}\r\n\r\ni18next.on(\"languageChanged\", lang => {\r\n    setLanguage(lang);\r\n});\r\n\r\nconst ajv = new Ajv({\r\n    allErrors: true,\r\n    addUsedSchema: false,\r\n});\r\naddFormats(ajv);\r\najv.addKeyword({\r\n    keyword: \"markdownDescription\",\r\n    schemaType: \"string\",\r\n    valid: true,\r\n});\r\n\r\nexport interface SchemaValidationSuccess {\r\n    type: \"success\";\r\n}\r\n\r\nexport interface SchemaValidationFailure {\r\n    type: \"failure\";\r\n    errors: ErrorObject[];\r\n}\r\n\r\nexport type SchemaValidationResult = SchemaValidationSuccess | SchemaValidationFailure;\r\n\r\nexport const isValidationFailure = (result: SchemaValidationResult): result is SchemaValidationFailure => {\r\n    return result.type === \"failure\";\r\n};\r\n\r\nexport type SchemaValidationFn = (data: any, dataCxt?: DataValidationCxt) => SchemaValidationResult;\r\n\r\nexport const compileSchema = (schema: object, addSchema: boolean = false) => {\r\n    if (addSchema) {\r\n        ajv.addSchema(schema);\r\n    }\r\n    const validator = ajv.compile(schema);\r\n    return (data: any, dataCxt?: DataValidationCxt): SchemaValidationResult => {\r\n        const valid = validator(data, dataCxt);\r\n        if (!valid) {\r\n            if (validator.errors && mapper) {\r\n                mapper(validator.errors);\r\n            }\r\n            return {\r\n                type: \"failure\",\r\n                errors: validator.errors ?? [],\r\n            };\r\n        }\r\n        return {type: \"success\"};\r\n    };\r\n};\r\n\r\nexport const validate = (schemaKeyRef: object | boolean, data: any): SchemaValidationResult => {\r\n    const valid = ajv.validate(schemaKeyRef, data);\r\n    if (typeof valid !== \"boolean\") {\r\n        throw new Error(\"No $async validation allowed\");\r\n    }\r\n    if (!valid) {\r\n        if (ajv.errors && mapper) {\r\n            mapper(ajv.errors);\r\n        }\r\n        return {\r\n            type: \"failure\",\r\n            errors: ajv.errors ?? [],\r\n        };\r\n    }\r\n    return {type: \"success\"};\r\n};\r\n\r\nexport const validateJsonSchema = (schema: object): SchemaValidationResult => {\r\n    const valid = ajv.validateSchema(schema);\r\n    if (valid) {\r\n        //ajv.compile(schema);\r\n        return {type: \"success\"};\r\n    }\r\n    if (ajv.errors && mapper) {\r\n        mapper(ajv.errors);\r\n    }\r\n    return {\r\n        type: \"failure\",\r\n        errors: ajv.errors ?? [],\r\n    };\r\n};\r\n\r\nexport const translateValidationErrors = (errors: ErrorObject[]) => {\r\n    if (mapper) {\r\n        mapper(errors);\r\n    }\r\n    return errors;\r\n};\r\n\r\n//Force internal schemas compilation (and caching) in the correct order.\r\nexport const validateUiSchema = compileSchema(uiSchemaSchema, true);\r\nexport const validateUiSchemaLibrary = compileSchema(uiSchemaLibrarySchema, true);\r\nexport const validateContextTypeSchema = compileSchema(contextTypeSchema, true);\r\nexport const validateSimulationStateSchema = compileSchema(simulationStateSchema, true);\r\nexport const validateWidgetDefinitionSchema = compileSchema(widgetDefinitionSchema, true);\r\nexport const validateDashboardDefinitionSchema = compileSchema(dashboardDefinitionSchema, true);\r\nexport const validateRecognizedImageBatchSchema = compileSchema(recognizedImageBatchSchema, true);","var map = {\n\t\"./ar/index\": [\n\t\t432,\n\t\t9\n\t],\n\t\"./ca/index\": [\n\t\t433,\n\t\t10\n\t],\n\t\"./cs/index\": [\n\t\t434,\n\t\t11\n\t],\n\t\"./de/index\": [\n\t\t435,\n\t\t12\n\t],\n\t\"./en/index\": [\n\t\t123\n\t],\n\t\"./es/index\": [\n\t\t436,\n\t\t13\n\t],\n\t\"./fr/index\": [\n\t\t437,\n\t\t14\n\t],\n\t\"./hu/index\": [\n\t\t438,\n\t\t15\n\t],\n\t\"./id/index\": [\n\t\t439,\n\t\t16\n\t],\n\t\"./it/index\": [\n\t\t440,\n\t\t17\n\t],\n\t\"./ja/index\": [\n\t\t441,\n\t\t18\n\t],\n\t\"./ko/index\": [\n\t\t442,\n\t\t19\n\t],\n\t\"./nb/index\": [\n\t\t443,\n\t\t20\n\t],\n\t\"./nl/index\": [\n\t\t444,\n\t\t21\n\t],\n\t\"./pl/index\": [\n\t\t445,\n\t\t22\n\t],\n\t\"./pt-BR/index\": [\n\t\t446,\n\t\t23\n\t],\n\t\"./ru/index\": [\n\t\t447,\n\t\t24\n\t],\n\t\"./sk/index\": [\n\t\t448,\n\t\t25\n\t],\n\t\"./sv/index\": [\n\t\t449,\n\t\t26\n\t],\n\t\"./th/index\": [\n\t\t450,\n\t\t27\n\t],\n\t\"./zh-TW/index\": [\n\t\t452,\n\t\t28\n\t],\n\t\"./zh/index\": [\n\t\t451,\n\t\t29\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(function() {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn Promise.all(ids.slice(1).map(__webpack_require__.e)).then(function() {\n\t\treturn __webpack_require__.t(id, 7);\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.id = 389;\nmodule.exports = webpackAsyncContext;","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      process.env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import \"./libs/wdyr\";\r\nimport ReactDOM from \"react-dom\";\r\nimport \"react-grid-layout/css/styles.css\";\r\nimport \"../node_modules/react-resizable/css/styles.css\";\r\nimport \"cropperjs/dist/cropper.css\";\r\nimport \"m-react-splitters/lib/splitters.css\";\r\nimport \"react-sortable-tree/style.css\";\r\nimport {setAutoFreeze} from \"immer\";\r\n\r\nimport \"./index.css\";\r\nimport * as serviceWorker from \"./serviceWorker\";\r\nimport {initializeI18n} from \"./libs/i18next\";\r\nimport {setupYup} from \"./libs/yup\";\r\n\r\nconst promise: Promise<any> = initializeI18n();\r\nsetAutoFreeze(false);\r\n\r\npromise\r\n    .then(\r\n        () => {\r\n            setupYup();\r\n            return import(\"./main\"); // Don't load app until i18n is initialized\r\n        },\r\n        error => {\r\n            ReactDOM.render(<div>{error.toString()}</div>, document.getElementById(\"root\"));\r\n        }\r\n    )\r\n    .finally(() => {\r\n        // If you want your app to work offline and load faster, you can change\r\n        // unregister() to register() below. Note this comes with some pitfalls.\r\n        // Learn more about service workers: https://bit.ly/CRA-PWA\r\n        serviceWorker.unregister();\r\n    });\r\n","import {ErrorObject} from \"ajv\";\r\nimport {ErrorInfo} from \"./error-info\";\r\n\r\n/*eslint-disable no-new-func*/\r\n\r\nexport interface ImportSucceeded<T> {\r\n    type: \"success\";\r\n    result: T;\r\n}\r\n\r\nexport interface ImportFailed {\r\n    type: \"failure\";\r\n    errors: ErrorInfo[];\r\n}\r\n\r\nexport type ImportResult<T> = ImportSucceeded<T> | ImportFailed;\r\n\r\nexport const importSuccess = <T>(result: T): ImportSucceeded<T> => {\r\n    return {\r\n        type: \"success\",\r\n        result,\r\n    };\r\n};\r\n\r\nexport const importFailure = (errors: ErrorInfo[]): ImportFailed => {\r\n    return {\r\n        type: \"failure\",\r\n        errors,\r\n    };\r\n};\r\n\r\nexport const isImportFailure = <T>(result: ImportResult<T>): result is ImportFailed => {\r\n    return result.type === \"failure\";\r\n};\r\n\r\nexport const mapAjvErrors = (errors: ErrorObject[], basePath?: string): ErrorInfo[] => {\r\n    return errors.map(e => {\r\n        const params = Object.entries(e.params)\r\n            .map(([key, value]) => `${key}: ${value}`)\r\n            .join(\"; \");\r\n        return {\r\n            dataPath: (basePath ?? \"\") + (e.instancePath ?? \"\"),\r\n            message: `${e.message} (${params})`,\r\n        };\r\n    });\r\n};\r\n"],"sourceRoot":""}